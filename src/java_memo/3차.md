# 3차
- 간단한 자기소개

    - 정말 짧게 해달라, 개발자가 되기 위해 어떤 공부를 해왔는지 위주로 해달라, 지원동기와 함께 말해달라 등.. 여러 방식으로 변형해서 요청한다
      - 자기소개는 그냥 정해진 대로 대답하지 말고 있는 자신 그대로를 말하자. 뭘 관심있어하는지 등등..
      - 나를 매력적으로 어필해야한다!!

- 자신이 생각하는 성격의 장단점과 단점을 개선하기 위해 노력하는 방법 (사례와 함께 소개해달라)

- 개발자로서의 목표가 있는지, 5년 후/10년 후 목표

- 회사에 지원하게 된 동기, 우리 회사를 선택한 이유는?

- 우리 회사는 어떻게 알게 되었는지, 무엇을 하는 회사인지 조사해본 내용을 알려달라

- 개발 직무를 선택한 이유는 무엇인가?
---

### 자료구조&알고리즘

- 정렬 알고리즘 아는 게 있다면 하나 설명해봐라
    - 버블 정렬 : 정렬 과정에 거품이 수면으로 올라오는 모습과 흡사해 지어진 이름이다.<br>
      비교와 교환 모두 일어날 수 있기에 코드는 단순하나, 복잡도는 굉장히 높아 성능적으로는 좋지 못하다. (N^2)
- 탐색 알고리즘에는 어떤게 있고, 특징은 무엇인지? (BFS, DFS...)
    - BFS : 너비 우선 탐색으로, 재귀적으로 동작하지 않는다. 보통 Queue를 이용해 구현한다. (방문한 노드들을 차례로 저장한 후 꺼낼 수 있는 자료 구조이기에)
      루트노드에서 시작한 인접노드를 먼저 탐색하는 방법이다.
    - DFS : 깊이 우선 탐색으로, 보통 재귀의 형식이나 Stack이며 모든 노드를 방문하고자 할 때 해당 알고리즘을 선택한다.
      검색 속도 자체는 BFS보다 느리며 루트노드에서 다음 분기로 넘어가기 전에, 해당 분기를 모두 탐색하는 방법이다.
- 컬렉션 프레임워크의 종류에 대해 각각 설명해달라 (List, Set, Map)
    - CollectionFramework.md 확인
- 프로젝트를 진행하면서 특정 자료구조/알고리즘을 사용해 문제를 효율적으로 해결한 경험이 있다면 소개해달라

### Java, Spring

- 객체지향 프로그래밍의 특징 (상속/추상화/다형성/캡슐화)에 대해 설명해달라
    - 상속 : 상속은 Super Class로, 기능을 확장하는 데에 의미가 있다. 그 기능을 이어 받아 사용할 수 있으며
      Overriding 키워드를 이용해 메서드를 Custom하게 만들 수 있다. 다형성과도 큰 연관이 있다.
    - 추상화 : 대표적으로 추상 클래스(Abstract Class)를 말할 수 있다. 상속과 마찬가지로 기능을 이어 받아 사용할 수 있으며
      Overriding을 이용해 Custom 하게 만들 수 있다. 하지만 상속과 다른 점은 Abstract 키워드이다. 이 키워드는 해당 껍데기 메서드를
      강제로 구현하게 한다. (Interface 와 이 점은 비슷하다.) 그리고 특징으로는 Class를 조금 더 Custom하게 만들 수 있게
      해준다는 것이다. 앞서 말했듯 구현을 강제로 하지만 인터페이스와는 다르게 커스텀하게 만들 수 있기 때문이다.
    - 다형성 : 상속과 연관지을 수 있는데, 하나의 Super Class로 여러 클래스가 이를 상속받게 한다면 다형성이라 말할 수 있다.
      정확히는 하나의 객체가 여러 가지의 타입을 가질 수 있는 것을 말한다.
    - 캡슐화 : 객체 내의 정보 손상과 오용을 방지하고 데이터가 변경되어도 다른 객체에 영향을 주지 않아 독립성이 좋다.
      캡슐화는 접근제어자를 통해 이루어진다.

- Java 11을 사용했다고 하는데, Java 11의 특징은 무엇인지?
    - ~~Optional의 지원과 람다,~~ String 메서드 추가, 그리고 **GC의 Base가 G1GC**로 변경되었다. 그래서 프로젝트를 생성할 때 기존에 있는
      ~~Java8과 11 둘 중 무엇을 고를지 고민이 되었는데, NULL에 대한 처리를 지원해주는 Optional 그리고 GC의 변경으로
      11을 선택하게 되었다. Optional로 주로 findBy를 사용할 때 Null 체크를 사용하게 되었고, 기존의 for문으로 처리했던 과정들을
      Stream(java8)을 통해 연습도 해볼 겸 사용해왔다.~~ <br>
    - Collection의 toArray() 기능 추가로 인해 자유자재로 배열로 반환할 수 있게 되었다.
    - Javac를 통해 컴파일하지 않고도 바로 java 파일을 실행할 수 있게 되었다.
      그리고 새로 시작한 팀 프로젝트에서도 ~~Stream을 통해 sum 메서드~~를 이용해 덧셈 연산도 쉽게 처리하였다.
    - 다시 Reference Check 해야하는 부분.
    - ~~람다식과 스트림을 답변,~~ 람다식과 스트림은 무엇인가?
        - 람다식은 익명 함수라고도 말할 수 있다. 단순히 이야기 하자면 수학에서 사용하는 함수를 보다 단순하게 표현하고자 하는 방법이다.
          하지만 오히려 람다식에 대해 익숙지 않은 사람에게는 알아 보기에 어려우며 람다식의 호출이 까다롭다. 장점으로는 코드가 간결해지며 가독성을 챙길 수 있게 된다.
            - Stream은 Java8부터 지원하는 컬렉션, 배열 등 저장된 요소들을 하나씩 참조하며 코드를 실행할 수 있게 하는 기능입니다.
              여러 기능들을 지원하며, 그만큼 많음 메서드들이 존재합니다. Stream은 데이터를 변경하지 않으며 재사용할 수 없습니다. (한 번 시작하면 끝까지 감. 중간 디버깅 불가능)
              중개연산과 종료연산으로 나뉘어져 있습니다.
    - 함수형 프로그래밍이 무엇인가? (잘 모름)
        - 하나의 프로그래밍 패러다임으로 정의되는 일련의 코딩 접근 방식이며,
          자료처리를 수학적 함수의 계산으로 취급하고 상태와 가변 데이터를 멀리하는 프로그래밍 패러다임을 의미한다.
    - 스트림 사용해 봤는지? 반복문을 사용했을 때랑 성능 차이를 직접 비교해보았는가?
        - Stream을 사용해서 일반 for문과 성능 차이를 비교해 보았습니다. 일반적으로는 for문이 미세하게 더 시간적으로는 빨랐습니다.
          성능적으로는 미약하게 차이가 났습니다. 하지만 속도 측면에서는 이런 차이점이 있으나 개인적으로 중요한 차이점으로는
          병렬의 지원이라 생각합니다. parallelStream을 지원하며 병렬처리가 가능함으로써 처리를 할 수 있어서 좋다고 생각합니다.
          하지만 이의 성능이 좋게 보여지진 않았습니다. for문과 비교를 해 봤을 때 속도 측면에서는 10배에 가까이 차이가 났기 때문입니다.
          (일반적인 for문과 비교했기 때문 for문은 지원하지 않는다.)
    - 스트림과 반복문의 차이가 무엇인지?
        - 앞의 답변 참고
- Call by Value와 Call by Reference에 대해 설명해달라
    - Java는 Value 언어이다.
        - Call by value(값에 의한 호출)는 인자로 받은 값을 복사하여 처리를 한다. <br>
          Call by reference(참조에 의한 호출)는 인자로 받은 값의 주소를 참조하여 직접 값에 영향을 준다.

간단히 말해 값을 복사를 하여 처리를 하느냐, 아니면 직접 참조를 하느냐 차이다
- **추상 클래스와 인터페이스의 차이**
    - 애초에 추상 클래스와 인터페이스는 **의도의 차이**이다. <br>
      공통점은 추상 클래스의 추상 메서드는 인터페이스와 같이 추상 메서드를 구현하게끔 강제한다.
      하지만 **추상 클래스**는 공통적으로 사용할 메서드들도 구현함과 동시에 어떤 각각의 클래스들을 상속해서
      커스텀하게 쓰려는 의도이다. 그러니 반드시 커스텀을 안 해도 된다는 것이다. (해도 됨)

인터페이스는 구현할 메서드(Body가 없는 빈 껍데기)를 강제로 구현함에 있어서 의도가 있다는 것이다.

- 인터페이스는 왜 사용하는가?
    - 인터페이스는 여러 이유로 사용하게 됩니다. 예를 들어 공통적인 메서드를 사용하고자 할 때,
      여러 클래스에 같은 기능을 복잡하게 나뉘어 쓰는 것보다 인터페이스를 통해 빈 껍데기로
      그 기능을 구현하는 데에 사용합니다. 그리고 기능 교체에 용이합니다. 마지막으로 상속과는 다르게 다중 상속(구현)이 가능케 합니다.
      하지만 오히려 인터페이스의 사용이 복잡도를 더욱 늘릴 수도 있습니다. 따라서 인터페이스의 활용도가 적다면
      과감히 인터페이스를 사용하지 않는 것이 좋습니다.
- **스프링 프레임워크는 요청을 어떻게 처리하는지 전반적인 흐름**을 설명해봐라
    - 요청이 들어올 때 먼저 Server(tomcat)에 도달합니다. 그 후 필터(Spring 밖)를 통해서 어떠한 필터링이 거치게 되며
      거치게 된 데이터들이 HandlerInterceptor(Spring Container범위 안)를 또 거치게(가로채게) 됩니다. 그렇게 들어온 요청의 값들이
      Dispatcher Servlet을 도달하게 됩니다. 여기서 들어온 데이터를 Handler Mapping이 URL에 맞는
      Controller를 찾으며, 찾은 Controller가 있다면 Handler Adapter에게 전달하여 그 Adapter가 연결해주는 역할을 합니다.
      해당 Controller를 실행시키고 그 안의 URL 정보와 여러 데이터들이 Service(비즈니스 코드)를 따라 들어가게 됩니다.
      Service(비즈니스 로직) 내에서 Repository(DAO)를 의존해 DB에 필요한 데이터를 조회, 저장 등 실행하게 되고
      다시 데이터들을 역순으로 보내게 됩니다. 이 데이터들을 view resolver가 가지고 가 Dispatcher Servlet에게 전달해 주고
      이 데이터를 Dispatcher Servlet이 받아 view(client)로 뿌려주게 됩니다.
- 스프링 프레임워크는 왜 쓰나? 스프링의 특징에 대해 아는대로 이야기 해봐라

    - 다시 알아볼 것

- JPA를 사용했던데 Mybatis 사용해본 경험이 있는지? JPA와 Mybatis는 무엇이 다른지?
    - SQL Mapper와 ORM은 개발자가 직접 JDBC Programming을 하지 않도록 기능을 제공해주는 Persistence Framework 종류이다.
    - **SQL Mapper(MyBatis) : MyBatis는 SQL Mapper 중 하나이고, Object 와 SQL 필드를 매핑하여 데이터를 객체화하는 기술이다.
      보통 JPA에 비해서 보다 복잡한 SQL문을 처리하기 위해 사용하는 용도로 쓰인다. 참고로 객체와 테이블 간의 관계를 매핑하는 것은 아니다.
    - ORM(JPA) : JPA는 ORM 기술 중 하나이고, Object 와 DB TABLE을 매핑하여 데이터를 객체화하는 기술이다.**
      MyBatis와는 다르게 JPA에서 메서드 시그니처를 통해 SQL문을 자동으로 작성이 가능케 한다.
      하지만 복잡한 쿼리의 작성은 메서드 시그니처를 통해 작성이 어려울 때가 있다. 개발자가 반복적인 SQL문을 따로 작성하지 않아도
      JPA의 자동 생성을 통해 생산성을 늘릴 수 있다.
- JPA의 특징이 무엇인지?
    - 위에서 이야기 했듯, MyBatis와는 다르게 SQL문을 자동으로 생성하게끔 하여 생산성을 늘린다.
      그리고 영속성 컨텍스트를 이용해 1차 캐싱으로 DB에 부하를 덜 줄 수 있게 한다. DB 테이블과 Object 관계를 매핑하여
      객체화하기 때문에 조금 더 직관적이라 말할 수 있다.
      <br>
      개인적인 생각으론 생산성의 장점이 가장 크다고 생각한다.
- 동기, 비동기의 차이를 아는지?
    - 동기의 경우, 앞의 작업이 끝날 때까지 기다려야 하며 작업이 끝난 후에 실행하게 된다. <br>
      그렇기 때문에 작업의 순서를 더 중요시 한다. 싱글스레드의 경우 동기에 속한다.
    - 비동기의 경우, 앞의 작업이 끝나지 않아도 작업을 실행할 수 있다. <br>
      위의 동기와 다르게 작업이 끝나지 않아도 실행하기 때문에 순서와는 관계없이
      여러 작업을 한번에 처리하기 위함이 있을 때 사용한다. 멀티스레드의 경우 비동기에 속한다.
    - 따라서 이 둘의 장단점과 사용할 상황을 고려해 선택하는 것이 맞다.
---
- 비관적 Lock, Redis Lock
    - 비관적 Lock에서 Redis Lock으로 변경한 이유는 무엇인가?
        - (DB IO가 특히나 많이 발생하고, READ를 많이 하는 곳에선 안 쓰인다 리뷰를 들어서 DB LOCK을 안 쓰게 됨)
        - 하지만 DB IO가 많이 발생해서는 아니다. 비관적 Lock은 애초에 DB Lock을 걸어서 읽는 것도
          Transaction을 걸어버려서 끝날 때까지 기다려야하는데, 물론 빨리 끝나면 좋겠지만 그렇지 않을 경우도 많음.

- 비관적, 낙관적 중 전자를 택한 이유?
    - 해당 프로젝트에서는 채팅방 입장과 채팅방 내에서 채팅이 주 도메인 서비스이기때문에
      입장과 퇴장에 관해서는 중요하게 생각했다. 또한 사용자가 몰려서 채팅방 제한수를 많이 넘어갈 것이라 가정했기 때문에
      미리 락을 걸어서 해결하고자 했다.
- Spring security 에서 BCrypt (salt)자동 관리가 어떻게 되는지?
    - DB 내에 자체적으로 저장하는 것이 아닌 value 앞에 salt를 붙여서 관리를 하게끔 만든다.
        - 그렇다면 salt는 어떻게 생성되는가?
            - security 내부적으로 임의의 문자열을 생성해서 기존의 사용자 비밀번호에 덧붙여서 생성하게 된다.<br>
              그래서 비밀번호와 솔트값을 더한 문자열로 해싱(키 스트레칭)을 통해 새로운 문자열을 만들어 저장하게 된다.
                - salt는 그럼 노출되어도 상관없는가?
                    - 그렇지 않다. 레인보우 테이블에 salt를 해싱한 값들을 따로 저장해두어 데이터를 찾아낼 수 있다.
                      그래서 그 값과 비밀번호를 레인보우 테이블로 찾아내어 사용자의 암호를 알 수 있다는 것이다. <br>
                      그리고 솔트의 경우는 하나로만 사용하게 될 경우, 이러한 암호가 뚫릴 우려가 있기에 매번 사용자마다
                      고유의 새로운 솔트를 만들어 함께 저장하게 된다. 그 솔트를 db에 저장하기에는 비용이 너무 크기 때문에
                      앞서 이야기 했듯이 value 앞에 붙여서 관리하게 되는 것이다.
### JPA
- N + 1은 왜 발생하는지?
    - 다양한 상황에서도 N+1의 문제는 발생할 수 있다.
    - 엔티티에 LAZY속성을 걸어두었을 때로 발생할 수 있다. 예를 들어 A의 엔티티와 B의 엔티티가 있을 때 조회를 할 경우
      LAZY로 설정해 두었기 때문에 프록시로 임시로 가져온다. 그리고 그 엔티티 안에 데이터를 꺼내올 때 1차 캐싱에서 데이터의
      유무로 판단해 없다면 하나씩 가져오게 되는데 그때 N+1이 발생한다.
        - 그렇다면 N+1은 어떻게 해결하는가?
            -  여러 방법이 있겠지만 fetch join으로 해결해 나갔다. fetch join은 연관된 엔티티나 컬렉션을 한 번에
               같이 조회(1차 캐싱에 올려둠)하는 기능이다. 그래서 이전과 다르게 DB까지 거치지 않고 1차캐싱에서 바로바로
               데이터를 가져오기 때문에 추가적인 쿼리도 안 나가게 되고 부하를 줄일 수 있게 되는 것이다.

- Join과 fetch Join의 차이점은 무엇인지?
    - 알아보기 (영속성 컨텍스트의 차이)
        - JOIN과 FETCH JOIN은 위에서 봤듯이 영속성 컨텍스트(1차 캐싱)의 차이이다. JOIN의 경우 두 테이블 간에
          데이터를 합치거나 포함되어 있는 데이터들을 본다던지 어떠한 조건절을 통해 데이터를 가져온다. <BR>
          FETCH JOIN의 경우 JPA에서 데이터를 조회하게 될 때 1차 캐싱에 올려두어 데이터를 바로 가져올 수 있게끔 하는 것이다.

- 그렇다면 EAGER를 사용해서 다 가져오면 되지 않는가?
    - 연관관계가 있는 엔티티는 신경쓰지 않고 조회 대상이 되는 엔티티 기준으로만 쿼리를 만든다. 그래서 데이터를 조회한 후
      JPA에서 연관된 엔티티가 있는지 확인한 후(EAGER) 바로 가져오게 되는데 그때도 N+1이 발생하게 된다.
- 1차 캐싱과 2차 캐싱은 무엇이고, 차이점은 무엇인지?
    - 1차 캐싱
        - 1차 캐싱은 영속성 컨텍스트에 Entity를 올려 두어, 조회 등의 작업들을 할 때 자신이 찾으려는
          데이터가 있다면 DB로 가서 별도의 쿼리를 날리지 않고 이 영속성 컨텍스트에 있는 데이터를 바로 가져온다.
          이를 1차 캐싱이라 부르고, 변경된 데이터를 SAVE를 할 경우 이를 내부적으로 `더티체킹`작업을 통해 UPDATE 쿼리문을 날려
          데이터의 정합성을 맞춘다.
    - 2차 캐싱
        - 2차 캐싱은 Application 캐시라고도 하고, 공유 캐시라고도 부른다. 보통 1차 캐싱에서 데이터가 없을 경우
          2차 캐싱까지 넘어가서 데이터를 확인하는 경우에 쓰인다. 영속성 컨텍스트는 1차 캐시에는 없는 Entity 가 필요한다면 2차 캐시를 사용한다.
          만약 거기에도 없다면 DB를 조회하고, 결과를 2차 캐싱에 보관한다.
          2차 캐시는 자신이 보관하고 있는 Entity를 복사하여 반환한다.
          이는 원본을 주는 것이 아닌, 조회 시 복사본을 반환한다.