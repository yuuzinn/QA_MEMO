>-- 항상 결과(정답)을 먼저 얘기하고(길면 1분), 뒤에 늘여서 얘기할지 물어볼 것. 만약 안된다 하면 킵하고 면접 끝날때 쯤
"아까 ~~ 이거에 관해서 더 말씀드리고 싶은 게 있는데 괜찮을까요" 물어보고.. --


### int 와 Integer의 차이점은 무엇인가?

- int
    - 기본 자료형이다.
    - null로 초기화가 불가능하다.
    - Stack이라는 영역에 저장되어 처리한다. 계산할 때 보다 빠른 처리가 가능하다.
- Integer
    - 참조 자료형이다. (래퍼 클래스)
    - null값 처리가 가능하다.
    - 객체로 연산을 처리할 수 있게 된다. Wrapper 클래스라고도 부르며, Integer가 아닌 다른 Wrapper Class
      도 Number 라는 abstract class를 확장한다.
    - 겉으로 보기엔 참조 자료형이나, 기본 자료형처럼 사용할 수 있다. 왜냐하면, Java compiler에서 자동으로 형변환을 해주기 때문이다.
    - parseType() - 기본자료형 return, valueOf(), toString() (주로 String 타입으로 변환) - 참조자료형 return 메서드를 지원한다.
```
valueOf() - parameter 가 null 이라면, 문자열 "null"을 만들어서 return
toString() - 값이 null이라면, NPE 발생을 시키고 Object에 담긴 값이 String이 아니더라도 return
```
### Integer 와 같이 참조 자료형을 만든 이유는 무엇일까 ?
- **매개 변수를 참조 자료형으로만 받는 메서드를 처리하기 위해**
- **제네릭과 같이 기본 자료형을 사용하지 않는 기능을 사용**하기 위해
- **MIN_VALUE(최소값), MAX_VALUE(최대값)와 같이 클래스에 선언된 상수 값**을 사용하기 위해
- **문자열 <-> 숫자 쉽게 변환(valueOf), 2, 8, 10, 16 진수 변환**을 쉽게 처리하기 위해

### Array와 Map의 차이점은 무엇인가?

- Array
    - 같은 자료형의 모음이다. (연속된 요소의 모음)
    - 크기가 처음에 정해져 있다.
- Map
    - Collection 중 하나이다.
    - Key - Value 형식의 데이터 모음이다.
    - 같은 자료형의 모음이나, 여러 참조 자료형 클래스로 모을 수 있다.
    - 크기가 처음부터 정해져 있지 않다.

### Inner Join 과 Left Join 의 차이점은 무엇인가?

- Left Join
  - 왼쪽 테이블 기준으로 Record가 나타난다. 왼쪽 테이블의 column이 있고, 오른쪽 테이블엔 없는 경우 나타난다.
    - 반대로, 오른쪽 테이블에만 있을 경우 Left Join 기준, column이 나타나지 않음.
        - 하나의 Table과 이어지는 Table의 조건으로 묶어서 데이터를 받는다.
        - 합집합의 개념이긴 하나, 두 테이블 전체를 말하는 것은 Full Outer Join.
- Inner Join
    - 두 Table 제약 조건을 걸어 서로 중복되는 데이터를 받는다. (교집합)

### PK와 UK의 공통점과 차이점은 무엇인가?

- 공통점
    - 중복이 안 된다.
- 차이점 (MySQL)
    - PK
        - 인덱스 자체가 데이터와 같이 붙어 있음.
        - Insert가 빠르게 할 수 있는 방법  : 보통 Auto Increment로 사용해서 번호를 매긴다.
        - 데이터 길이도 가장 짧게 설정할 수 있어서 Auto Increment를 사용했을 때의 장점이라고 말할 수 있다.
    - UK
        - 세컨더리 인덱스(PK를 참조하는 형식) - 제약조건의 성향이 강함 (상대적으로).
        - Insert가 PK보다 느리다. - 데이터의 중복을 검사하는 과정이 있기 때문이다.
        - 보통 UK의 경우 EMAIL이나 NINKNAME 같은 것들을 하기 때문에 데이터의 길이가 상대적으로 길다.

### String과 StringBuilder or StringBuffer 중 문자열에 대해 추가나 삭제 수정 등 작업이 많이 이루어질 것이라 예상될 때, 어떤 것이 더 효율적인가?

- ~~효율적(속도면)같은 것으로 보았을 때는 별반 차이는 없을 것이나, 메모리적으로 생각했을 때는 StringBuilder 사용이 맞다. String의 + 연산자는 메모리를 많이 잡아 먹기 때문이다. 문자열 연결 연산자( + ) 및 다른 개체를 문자열로 변환하는 데 특별한 지원을 제공한다.~~
- StringBuilder 가 더 우세하다.
  - append 메서드를 통해서 문자열들을 빠르게 더해줄 수 있음.
  - 반면에, String 인스턴스(불변(클래스))를 통해서 두 문자열을 더해준다면 완전히 새로운 String 인스턴스가 생성됨. 애초에 그렇게 되면 메모리적으로도 String 인스턴스가 3개인 셈임.
  - 속도와 메모리 측면으로 보아 StringBuilder가 훨씬 우세함.
- ### 그렇다면, 예를 들어(”Hi” → “Hello”) 문자열 변환에 있어서 더 효율적인 것은 ?

- String 의 경우 불변 클래스여서 위와 같이 새로운 문자열로 생성하게 될 경우, 기존의 객체가 아닌 새로운 객체로 인식이 된다. 기존 객체는 곧 GC의 대상이 되며, 잦은 변환이 발생 시에 GC가 많이 발생하게 되어 메모리 적으로 좋지 못하다. 따라서 문자열 변환이 자주 일어나는 곳에선 StringBuilder가 효율적이다. (단일 스레드 기준이다. 멀티 스레드에선 Buffer)
- 그런데

    ```markdown
    String test = "te" + "st" + "hi";
    ```

  이런 식으로 처음부터 초기화를 할 때 더하기 연산으로 짓는 것은 둘 중 상관이 없다.

  하지만 for문이나 어떠한 연속적으로 계속 추가, 수정 등이 일어날 경우에는 StringBuilder를 사용하는 것이 맞겠다.

### Spring IoC 에 대해 설명해주세요

- Object Bean의 생성, 수정, 삭제 등을 코드가 관리하지만, Spring Container에서 역으로 코드 대신 관리하게 되는 것을 스프링 제어의 역전 (Spring IoC)라 한다.

### 프레임워크와 라이브러리의 차이점에 대해 말해주세요.

- 제어 흐름의 주도권이 어디에 있는지 차이점이 있다.
- 프레임워크는 전체적으로 흐름을 제어하고 있으며 개발자는 그 안에서 필요한 코드를 넣는 반면
- 라이브러리는 개발자가 전체적인 흐름을 만들며 라이브러리를 사용하는 것이다.


- 요약으로, 라이브러리를 사용하는 Application 코드는 Application 흐름을 직접 제어한다. <br>
  반면에 프레임워크는 거꾸로 Application 코드가 프레임워크에 의해 사용된다.
- 보통 프레임워크 위에 개발한 클래스를 등록해두고, 프레임워크가 흐름을 주도하는 중에 개발자가 만든
  Application 코드를 사용하도록 만드는 방식이다.