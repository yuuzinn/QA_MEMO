>-- 항상 결과(정답)을 먼저 얘기하고(길면 1분), 뒤에 늘여서 얘기할지 물어볼 것. 만약 안된다 하면 킵하고 면접 끝날때 쯤
"아까 ~~ 이거에 관해서 더 말씀드리고 싶은 게 있는데 괜찮을까요" 물어보고.. --


### 상속과 인터페이스는 무엇인가? 차이점까지.

- 상속(추상클래스)과 인터페이스는 상속받는 클래스 혹은 인터페이스 안에 있는 추상메서드를 구현하도록 강제합니다.
  - 아래의 답변은 살짝 애매합니다.. 이건 추상클래스와의 비교가 더 맞는 표현.
     - 추상클래스는 해당 클래스를 상속받아 기능을 이용하고, 확장시키는 데에 있으며,
     인터페이스는 함수의 껍데기만 있는데, 그 이유는 그 함수의 구현을 강제하기 위해서입니다.
     해당 메서드를 강제함으로써 구현 객체의 같은 동작을 보장할 수 있습니다.

정리하자면, **상속은 Super 클래스의 기능을 이용하거나 확장하기 위해서 사용되고,
다중 상속의 모호성때문에 하나의 클래스만을 상속받을 수 있습니다. 또한, Super 클래스의 메서드를 전부 Overriding 할 필요가 없습니다.
인터페이스는 해당 인터페이스를 구현한 객체들에 대해서 동일한 동작을 약속합니다. 다중 인터페이스를 구현할 수 있습니다.**
### 중요 (인터페이스 VS 추상 클래스)
**(추가 내용)
상속도 좋지만, 추상 클래스로 비교를 해보자.**

애초에 추상 클래스와 인터페이스는 **의도의 차이**이다.

공통점은 추상 클래스의 추상 메서드는 인터페이스와 같이 추상 메서드를 구현하게끔 강제한다.
하지만 **추상 클래스**는 공통적으로 사용할 메서드들도 구현함과 동시에 어떤 각각의 클래스들을 상속해서
커스텀하게 쓰려는 의도이다. 그러니 반드시 커스텀을 안 해도 된다는 것이다. (해도 됨)

인터페이스는 구현할 메서드(Body가 없는 빈 껍데기)를 강제로 구현함에 있어서 의도가 있다는 것이다.

### ArrayList에서 서로 비슷한 크기의 객체들을 저장하려 하는데, 어떻게 하면 효율적으로(성능적으로) 데이터를 넣을 수 있을지?

- 미리 초기 용량을 사용자 지정으로 정해두어 사용합니다.

List 안에는 DEFAULT_CAPACITY 즉, 10의 초기 용량을 지정해 두는데 데이터를 추가하게 된다면 이 용량이
자동적으로 증가하게 됩니다. 두 배 정도 증가하게 되는데 이는 메모리적으로 보아 손해를 볼 수 있습니다.

예를 들어 500개의 데이터를 저장해야 한다면 501 크기를 지정해 두어 1000 크기를 늘릴 수 없게 사용하는 만큼만
용량을 지정하면 효율적으로 저장할 수 있습니다.

### 비밀번호 암호화로 Bcrypt 암호화를 사용했는데, Bcrypt 암호화에 대해서 설명해주세요.

- BCrypt란 블로피시 암호에 기반을 둔 암호화 해시 함수로, 현재까지 사용 중인 가장 강력한 해시 매커니즘 중 하나입니다.

Bcrypt는 패스워드를 해싱할 때 내부적으로 랜덤 한 Salt를 생성하기 때문에
같은 문자열에 대해서 매번 다른 해싱 결과를 반환합니다. 하지만 반환되는 String의 길이는 60 동일합니다.
또, Bcrypt 안에 salt 값이 포함되어 있습니다.


### 그렇다면 Bcrypt 암호화에서 Salt 개념을 설명해 주세요.

- 실제 정보 이외에 추가적으로 무작위 데이터를 더해서 해시 값을 계산하는 방법입니다.

salt로 인해
해시 값이 달라지기 때문에, rainbow attack 같이 미리 해시 값을 계산해 하는 공격을 무효화 시킵니다.

salt는 비밀번호마다 모두 다르기 때문에 같은 비밀번호라도 해시값이 달라지게 됩니다.

_rainbow attack(rainbow table)은 해시 함수를 사용해 변환 가능한 모든 해시 값을 저장시켜 놓은 표입니다._

### Stream을 많이 사용하시고 작성도 해주셨었는데, for문과의 차이점을 설명해 주세요.

- 익숙함의 차이에서 오는 가독성의 호불호가 있습니다. <br>
  Stream의 장점은 가독성인데, 되레 Stream을 잘 사용하지 않은 분들이 보기에는 오히려 단점이 될 수 있습니다.
- 디버깅 난이도의 차이가 있습니다.
    - for 에러 발생 위치가 바로 노출됩니다.
    - Stream 지연 연산을 통해 실행되기에 에러 발생 시 위치를 추척해야 합니다.
- 병렬 처리 구현의 차이가 있습니다.
    - for 구체적인 로직을 나누어 구현하고 합쳐야 합니다.
    - parallelStream()으로 구현하며 쉽게 처리할 수 있습니다. (하지만 무분별한 Parallel은 성능을 많이 낮춥니다.)

### Stream의 장단점은 무엇이라 생각하시나요?

- Stream의 장점으로는 가독성 향상과 많은 연산의 지원, 병렬처리에 우수함입니다.
- Stream의 단점으로는 많이 사용하지 못한 인원에겐 좋지 못한 가독성, 순회 중단에 종료가 불가능합니다.
  그리고 Stream은 한번 수행되기 때문에 디버그가 힘들며, 한 번 쓰면 close 되기 때문에 한 번 정의해놓고 계속 사용이 불가능합니다.

### 동시성 해결에서 DB 비관적 락과 낙관적 락 키워드가 나왔는데, 둘은 무엇이며 차이점은 무엇인가요?

- 비관적 락은 `자원 요청에 따른 동시성 문제가 발생할 것이라 예상하고 락을 거는 방법론` 입니다. <br>
  하나의 트랜잭션이 자원에 접근했을 때 락을 걸고, 다른 트랜잭션은 접근하지 못합니다.
- 낙관적 락은 `자원을 접근할 때 락을 걸지 않고, 동시성 문제가 발생할 때 처리한다는 방법론` 입니다. <br>
  충돌이 나는 것을 막지 않고 충돌이 났을 때 처리합니다.

### Redis Session storage가 나왔는데, 만약 Redis Server가 다운이 된다면 어떻게 하실 건가요?

Redis Server가 다운이 된다면 Redis Server를 Cluster 처리해 하나의 Server가 다운이 되어도 다른 서버가 정보를 가지고 있게끔
처리할 것입니다.

### Redis Cluster 해도 최소 3개 이상의 Server가 있어야 하는데, 2개의 서버가 동시에 다운이 된다면 어떻게 되나요?
- 동시에 여러 개의 마스터 노드가 다운된 경우, Redis Cluster는 해당 노드들의 데이터의 가용성을 보장할 수 없습니다.

Redis Cluster는 다운된 Node(Server)를 감지하고 자동으로 장애 회복을 시도하는 내부 매커니즘을 가지고 있습니다.
Redis Cluster는 다운된 노드의 역할을 대체할 수 있는 새로운 마스터 노드를 선출하고, 해당 노드 데이터를 복제해
클러스터 전체의 가용성을 유지하려고 시도합니다.

이런 상황을 방지하기 위해 Redis Cluster를 구성할 때 충분한 수의 마스터 노드를 사용하며, 추가로 레플리카 노드를 구성해 고가용성을
확보해야합니다.

> 가용성(可用性, 영어: availability)이란 서버와 네트워크, 프로그램 등의 정보 시스템이 정상적으로 사용 가능한 정도를 말한다. 가동률과 비슷한 의미이다.

### LAZY와 EAGER는 무엇이고, 차이점은 무엇인가요?

- LAZY는 `지연로딩`으로 데이터를 가져올 때, 해당 데이터(객체)가 필요한 시점에만 가져오는 방식입니다.
- EAGER는 `즉시로딩`으로 말 그대로 데이터를 가져올 때, 하나의 객체만을 가져오는 것이 아닌 참조 객체들의 데이터까지 한번에 가져오는 방식입니다.

### CASCADE 를 사용하셨던데, CASCADE 란 무엇인가요?

- cascade 옵션이란, @OneToMany나 @ManyToOne에 옵션으로 줄 수 있는 값이다. 즉, **Entity의 상태 변화를 전파시키는 옵션**입니다.

만약 Entity의 상태 변화가 있으면 연관되어 있는 Entity에도 상태 변화를 전이시키는 옵션이다. 기본적으로는 아무것도 전이 X

### JPA 1차 캐싱과 2차 캐싱은 무엇인가요? 그리고 차이점은 무엇인가요?

- 1차 캐싱이란 영속성 컨텍스트 내부에는 엔티티를 보관하는 저장소가 있는데, 이를 1차 캐싱이라 말합니다. <br>
  특징으로는 같은 엔티티가 있으면 객체 동일성을 보장합니다.
- 2차 캐싱이란 Application의 캐시인데, 공유 캐시라고도 칭합니다. <br>
  특징으로는 Application이 종료할 때까지 캐시가 유지됩니다. 영속성 컨텍스트가 다르면 객체 동일성을 보장하지 않습니다.

### DI, IoC에 대해 설명해 주세요.

- IoC란 제어의 역전이라 말합니다. <br>
  Spring Application에서는 Bean의 생성과 의존 관계 설정, 사용, 제거 등의 작업을 Application 코드 대신 Spring Container가 담당합니다.
  이를 Spring Container가 코드 대신 오브젝트에 대한 제어권을 갖고 있다 해서 IoC라 부릅니다.

- DI란 쉽게 말해 객체들 간의 의존관계를 외부에서 결정하고 주입하는 것입니다. <br>
  의존 대상 B가 변하면, 그것이 A에 미친다라 합니다. 즉, B의 기능이 추가되거나 변경된다면 그 영향이 A에 미치는 것입니다.

- 차이점 ? DI는 의존관계를 어떻게 가질 것인가에 대한 문제이며, IoC는 누가 Software의 제어권을 갖고 있느냐의 문제입니다.
  IoC 컨테이너가 빈을 생성할 때 Bean들 간의 의존관계를 DI를 통해 해결합니다.(DI는 IoC를 필수로 요구하지 않습니다.)

### Spring MVC 전반적인 흐름에 대해서 설명해 주세요.

[Spring MVC 전반적인 흐름](https://github.com/yeb0/Java_Alone_Study/blob/master/src/java_deep/md/SpringMVC.md)

### Thread-Safe한 Map이 CunccrentHashMap인데, 이거 말고도 아시는 게 있을까요 ? (SynchronizedMap)

### 있다면 그 Map은 ConcurrentHashMap과 어떠한 차이점이 있나요?

- Collection 유틸리티 클래스(SynchronizedMap 포함)는 컬렉션에서 작동하고 래핑된 컬렉션을 반환하는 다형성 알고리즘을 제공합니다.


- SynchronizedMap() 메서드는 스레드로부터 안전한 기능을 제공합니다. 매개변수에서 Map이 지원하는 동기화된 Map을 반환합니다.<br>
  스레드 안전성을 제공하기 위해 synchronizedMap()은 반환된 Map을 통해 백업 Map에 대한 모든 액세스를 허용합니다.<br>
  **전체 컬렉션을 잠그게 되고, 객체 수준 잠금입니다. 이는 오버헤드입니다.** (한 스레드가 LOCK을 유지하는 동안 다른 스레드는 사용 X)


- ConcurrentHashMap()은 검색 및 업데이트에 대한 높은 동시성을 지원하는 HashMap의 향상 기능으로, JDK1.5에 도입되었습니다.<br>
  스레드로부터 안전하며, 여러 스레드가 복잡한 문제 없이 단일 객체에서 작동할 수 있습니다. <br>
  **객체 수준 잠금이 아닌 더 세분화 된 버킷 수준 잠금을 사용합니다.**<br>
  ConcurrentHashMap에서 **읽기 작업은 차단되지 않는 반면, 쓰기 작업은 특정 세그먼트 or 버킷을 잠급니다.**


### ConcurrentHashMap은 어떤 기준으로 LOCK을 획득하나요 ?

- ConcurrentHashMap의 put() 메서드 기준, 노드의 존재 유무로 LOCK을 획득하게 됩니다.<br>
  ConcurrentHashMap에서 처음 put() 메서드를 실행하게 될 때, 빈 해시 버킷에 노드를 삽입하는 경우 LOCK을 사용하지 않습니다.<br>
  이 과정 속에서 volatile 변수에 2번 접근하는 동안 원자성을 보장하기 위해 값을 비교해 새로운 노드를 넣고(swap)<br>
  Unsafe를 내부적으로 사용합니다.(JDK 11 부터는 사라졌습니다.)

- **이미 노드가 존재하는 경우, LOCK을 획득하게 되며 서로 다른 스레드가 같은 해시 버킷에 접근할 때만 해당 블록이 잠기게 됩니다.**


### 만약, 프론트엔드와 업무를 보던 도중 프론트에서 API 응답 속도가 너무 느리다고 말하는데, 이를 해결하기 위한 프로세스를 설명해 주세요.(단, 코드는 문제 없어 보입니다.)

- 네트워크 확인해봅니다.
- 백엔드 Server의 상태를 확인해 봅니다.
- 백엔드의 log를 확인해 봅니다.
- 요청 및 응답시간을 다시 재측정합니다. (test)
- 백엔드 데이터의 전송량을 확인합니다.
- 만약 위의 내용들 중 포함이 되지 않는다면 쿼리 개선이나 프론트엔드에서 자주 사용되는 데이터들을 캐싱합니다.

### 고아 객체에 대해 설명해주세요.

- 부모 Entity와 관계가 끊어진 자식 Entity를 고아객체라 부릅니다.

```
* cascade REMOVE 와의 차이점?

orhanRemoval은 관계 여부에 따라 달라지기 때문에, 자식엔티티가 삭제된게 아니더라도 부모와 관계가 끊어지면 지워진다. 
물론 부모엔티티가 지워져도 연결된 자식 엔티티들과 관계가 끊어지는 것이기 때문에 자식엔티티들도 삭제된다. orphanRemoval이 cascade remove보다 큰 개념.

고아객체 자동 삭제(orphanRemoval = true) 설정은 자식엔티티가 해당 부모엔티티랑만 관계를 맺을 때 사용해야한다. 
그렇지 않으면 다른 관계들도 삭제가 되기때문이다. 그리고 관계가 끊어져도 자식엔티티가 존재해야하는 상황에서는 사용하면 안된다.
```

영속성 전이(cascade)를 All로 두고, orhanRemoval 를 true로 둔다면, 부모와 자식의 생명주기를 같이 맞출 수는 있다.(조절가능)