>-- 항상 결과(정답)을 먼저 얘기하고(길면 1분), 뒤에 늘여서 얘기할지 물어볼 것. 만약 안된다 하면 킵하고 면접 끝날때 쯤
"아까 ~~ 이거에 관해서 더 말씀드리고 싶은 게 있는데 괜찮을까요" 물어보고.. --

### 여러 노드에서 동시에 작업이 발생할 때 일관성을 유지하려면 어떤 접근 방식을 사용해야 할지 ?
- 보통 여러 노드에서 동시에 작업이 발생할 때 일관성을 유지하기 위해선 분산 락을 사용하는 것이다. (무조건은 아님)
  분산 락은 여러 노드 간에 공유되는 락을 통해 동시에 하나의 작업만 접근할 수 있도록 제어함으로써 일관성을 유지할 수 있다.

- 이 외에도 여러 락으로 해결할 수 있는데, 스핀락, 뮤텍스, 세마포어가 있다.

- 스핀락 ? -> 임계 구역에 진입이 불가능할 때 진입이 가능할 때까지 루프를 돌면서 재시도하는 방식이다.
- 뮤텍스 ? -> 잠금 메커니즘은 스핀락과 동일하게 동작하나, 루프를 돌지는 않고 sleep 상태에 들어가고, wakeup 되면 다시 권한을 획득하기 위해 시도한다.
- 세마포어 ? -> 음수가 아닌 정수의 값을 가지고 스레드 간에 공유되는 변수이다. 이 변수는 임계 구역 문제를 해결하고 동기화를 구현하는 데에 사용한다.
### 데이터의 일관성을 해치지 않으면서 동시성 문제를 효율적으로 해결하는 방법에 대해 알고있는대로 설명
- Transaction isolation level에 따라서 격리 수준을 나뉘어 이를 해결할 수 있다.
- 낙관적 락 -> 락이 일어날 상황을 생각지 않고 있다가 필요한 상황에 그때 맞춰서 동작하게 된다. 업데이트 시 버전에 차이에 따라서 동기화를 진행한다.
- 비관적 락 ->  락이 일어날 상황을 미리 생각하고 Lock을 걸어둔다. 전체적으로 Lock을 걸어두기 때문에 성능적으로도 생각을 해 봐야만 한다.
### Redisson 라이브러리의 장점과 단점은 무엇인지? 그리고 왜 Redisson을 사용하기로 결정했는지
- 장점으로는 간편한 분산 락을 제공한다. 사용법을 익히기에는 간단하며 금방 익힐 수 있다. Redis 기반으로 되어 있기 때문에 속도가
  비교적으로 빠른 편이다. 단점으로는 Redis의 의존성이 있고. 분산 환경 설정 및 구성이 복잡하다. 라이브러리 자체가 어렵게 되어 있어 따로 익혀야만 한다.
###  어떤 상황에서 각각의 락을 사용하면 좋을지?
- 결제나 돈에 관련된 작업에는 높은 수준의 Lock을 걸어야 된다고 생각한다. DB 범위를 넓게 Lock을 건다던지, 조금 빡빡하게 잡기 위해
  비관적 Lock을 건다던지, 아니면 락이 필요한 상황에 따라 걸리게끔 만드는 낙관적을  사용한다던지... 상황마다 각각 맞게 사용해야한다.
### Fetch Join이란 무엇이고, 어떤 상황에서 사용해야 효과적인지?
- Fetch Join이란 연관된 Entity를 조회할 때 해당 Join한 Table의 entity를 프록시 객체가 아닌 진짜 객체를 가져오게끔 처리한다.
  영속성 컨텍스트에 객체들을 올려 두어서 조회를 하게 될 때 DB에 있는 데이터를 가져오는 것이 아닌 영속성 컨텍스트에서 가져오기 때문에 추가적인 쿼리가 날아가지 않는다.
- 보통 N+1의 문제가 있을 때 사용한다. N+1의 문제는 LAZY를 걸어두었을 때 뿐만 아니라 EAGER 속성을 걸어두었을 때도 발생할 수 있다.
### 동시성 이슈로 인해 서비스 성능 저하가 발생한 상황이 있을때 어떤 프로세스로 문제를 해결할것인지 이전 프로젝트에서 얻은 경험을 토대로 말하기
- ... 잘 모르겠다.
### EAGER는 언제 사용하면 좋은지?
- EAGER로 연관된 데이터를 한번에 가져와서 쿼리를 보내고 싶을 때 사용한다. 연관된 데이터가 항상 함께 필요한 경우도 이에 포함한다.
### jpa 테이블 매핑시에 테이블의 다형성 형태에 대해서 고민해봤는지 혹은 경험이있는지?
- ... 모르겠음.
### 로그인 기능 구현에서 팀원 간 의견 충돌이 있을 때 어떤 방식으로 합의점을 찾았는지 설명해주실 수 있는지
- 로그인 기능 구현에서 인터셉터와 시큐리티의 구현으로 의견 충돌이 있었다. 서로 의견이 맞지 않아 타협이 잘 되질 못했는데,
  팀 프로젝트였던지라 담당해주시던 멘토님이 계셔서 멘토님께 조언을 들었다. 물론 조언일 뿐 선택을 하는 것은 팀의 책임이라서
  조언을 듣고 의견을 맞춰 해결하는 방향으로 잡았다.
### 비슷한 상황이 다시 발생한다면 어떻게 해결하실 것인지?
- 아무래도 똑같은 방법으로 해결해 나가지 않을까 싶다. 만약에 자신이 알고 있는 내용과 너무 다를 경우라던지 어떤 그러한
  내용이 섞여 있다면 반론 정도는 해볼 거 같다.
### N+1 이슈를 Fetch join이 외에도 다른 방법으로 해결 가능한지?
- 이의 문제로 여러 방법으로 해결이 가능하다. 실제로 entity graph를 통해서 N+1의 문제를 해결해 보았다. entity graph를 사용한 이유는
  fetch join을 사용할 경우 limit(pageable)이 제대로 동작하지 않아 entity graph를 사용함으로써 N+1의 문제와 limit(pageable)을 제대로 동작할 수 있게끔 처리했다.
### Stream과 for loop의 차이점을 기반으로 추천하고자 하는 사용 사례들을 설명해주실 수 있는지, 그리고 어떤 경우에 어떤 방식을 선택하시는 것이 좋을지?
- 둘만의 차이가 있는데, 우선 stream와 for문의 속도 차이는 눈에 띌 정도로 차이가 나지 않는다. 그래서 일반적으로 team에 따라서 stream의 사용을 선호하는 분들이
  많을 경우에는 팀마다 컨벤션을 맞춰서 stream의 사용도 좋고, 그렇지 않다면 for loop를 통해서 처리하는 것도 좋은 방법이라 생각한다.
- 하지만 어떠한 특수한 경우, 예를 들어서 병렬처리를 해야할 경우라면 stream에서 지원해주는 병렬처리 연산을 이용하는 것이 좋은 방법이라 말할 수 있다.
  실제로 병렬 처리 stream은 for loop에 비해 꽤나 좋은 속도를 가졌지만 데이터가 얼마 없는 경우는 오히려 속도가 지연되는 경우가 있다. 그래서 이것도
  상황에 맞게끔 stream과 for loop를 사용하는 것이 옳다고 생각한다.
### JPQL과 Entity Graph의 관계를 설명해주세요. 여기서 FetchGraph와 LoadGraph의 차이점과 사용 시 주의점
- fetch graph는 entity를 로딩할 때 연관된 모든 entity들을 함께 가져오도록 한다. EAGER와 비슷한 결과를 낼 수 있다.
- load graph는 entity를 로딩할 때 연관된 entity 중 일부만 로딩된다. LAZY와 비슷한 결과를 낸다.
- FetchGraph와 LoadGraph는 엔티티 클래스 내부에 정의되어야 한다. @NamedEntityGraph 어노테이션을 사용하여 그래프를 정의한다.
  추가적으로 서브 그래프를 지정해 해당 그래프까지 한번에 가져올 수 있도록 지정할 수도 있다.
- 로딩 전략을 지정할 때, entity 클래스에 정의된 Fetch Type값과 함께 동작한다. EAGER로 연관관계를 정의해두면 FetchGraph는 그대로 유지한다.
- 순환참조에도 주의해야한다. 서로 entity 끼리 참조하는 일이 발생할 경우 순환참조가 발생해 무한로딩이 이어질 수 있으니 주의해야만 한다.